<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Droplets</title>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.11.7/lib/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #000;
        }
        #permission-button {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 15px 30px;
            font-size: 18px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            display: none;
            z-index: 1000;
        }
        #permission-button:hover {
            background-color: #0056b3;
        }
        #info {
            position: fixed;
            top: 10px;
            left: 10px;
            color: #333;
            background: rgba(255,255,255,0.9);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            max-width: 250px;
            z-index: 999;
        }
        #debug {
            position: fixed;
            bottom: 10px;
            left: 10px;
            color: #333;
            background: rgba(255,255,0,0.7);
            padding: 5px;
            border-radius: 3px;
            font-size: 10px;
            max-width: 250px;
            z-index: 999;
        }
        canvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
        }
    </style>
</head>
<body>
    <button id="permission-button">Enable Device Motion</button>
    <div id="info">
        <div>Tilt your device to move the pattern</div>
        <div>Tap/click to add droplets</div>
        <div id="status"></div>
        <div id="orientation-data"></div>
    </div>
    <div id="debug"></div>

    <script>
        let circles = [];
        let gridOffsetX = 0;
        let gridOffsetY = 0;
        let targetOffsetX = 0;
        let targetOffsetY = 0;
        let maskCanvas;
        let gridCanvas;
        let permissionGranted = false;
        let orientation = { alpha: 0, beta: 0, gamma: 0 };
        let motion = { x: 0, y: 0, z: 0 };
        let debugInfo = [];
        
        // Track display info
        let displayInfo = {
            pixelDensity: 1,
            windowWidth: 0,
            windowHeight: 0,
            canvasWidth: 0,
            canvasHeight: 0
        };
        
        function setup() {
            // Draw smooth graphics
            smooth();

            // Get the device pixel ratio for retina support
            displayInfo.pixelDensity = window.devicePixelRatio || 1;
            displayInfo.windowWidth = window.innerWidth;
            displayInfo.windowHeight = window.innerHeight;
            
            // Create canvas with proper dimensions
            createCanvas(displayInfo.windowWidth, displayInfo.windowHeight);
            
            // Handle retina displays properly
            pixelDensity(displayInfo.pixelDensity);

            displayInfo.canvasWidth = displayInfo.windowWidth;
            displayInfo.canvasHeight = displayInfo.windowHeight;
            
            debugInfo.push(`Window: ${displayInfo.windowWidth}x${displayInfo.windowHeight}`);
            debugInfo.push(`Canvas: ${displayInfo.canvasWidth}x${displayInfo.canvasHeight}`);
            debugInfo.push(`Pixel density: ${displayInfo.pixelDensity}`);
            
            // Ensure canvas has valid dimensions before creating graphics
            if (width > 0 && height > 0) {
                maskCanvas = createGraphics(displayInfo.windowWidth, displayInfo.windowHeight);
                gridCanvas = createGraphics(displayInfo.windowWidth, displayInfo.windowHeight);
                
                // Set pixel density for offscreen canvases too
                maskCanvas.pixelDensity(displayInfo.pixelDensity);
                maskCanvas.smooth();
                gridCanvas.pixelDensity(displayInfo.pixelDensity);
            }
            
            // Add debug info
            debugInfo.push('Setup completed');
            debugInfo.push('Browser: ' + navigator.userAgent.split(' ')[0]);
            debugInfo.push('HTTPS: ' + (location.protocol === 'https:'));
            
            // Show permission button if device motion/orientation is supported
            checkForDeviceSupport();
            
            // Set up permission button
            const button = document.getElementById('permission-button');
            button.addEventListener('click', handlePermissionClick);
            
            updateDebugDisplay();
        }
        
        function updateDebugDisplay() {
            const debugDiv = document.getElementById('debug');
            debugDiv.innerHTML = debugInfo.slice(-6).join('<br>');
        }
        
        function checkForDeviceSupport() {
            const button = document.getElementById('permission-button');
            const status = document.getElementById('status');
            
            debugInfo.push('Checking device support...');
            
            // Check if device supports orientation/motion events
            const hasDeviceOrientation = typeof DeviceOrientationEvent !== 'undefined';
            const hasDeviceMotion = typeof DeviceMotionEvent !== 'undefined';
            const hasRequestPermission = typeof DeviceOrientationEvent.requestPermission === 'function' ||
                                        typeof DeviceMotionEvent.requestPermission === 'function';
            
            debugInfo.push(`DeviceOrientation: ${hasDeviceOrientation}`);
            debugInfo.push(`DeviceMotion: ${hasDeviceMotion}`);
            debugInfo.push(`RequestPermission: ${hasRequestPermission}`);
            
            if (hasDeviceOrientation || hasDeviceMotion) {
                if (hasRequestPermission) {
                    // Need to request permission
                    button.style.display = 'block';
                    status.innerHTML = '<small>Permission required</small>';
                    debugInfo.push('Showing permission button');
                } else {
                    // Try to set up listeners directly
                    debugInfo.push('Setting up listeners without permission');
                    setupOrientationListeners();
                    status.innerHTML = '<small>Device motion active</small>';
                    permissionGranted = true;
                }
            } else {
                // No device motion support
                status.innerHTML = '<small>Using mouse/touch</small>';
                debugInfo.push('No device motion support - using mouse');
                permissionGranted = false;
            }
            
            updateDebugDisplay();
        }
        
        async function handlePermissionClick() {
            const button = document.getElementById('permission-button');
            const status = document.getElementById('status');
            
            debugInfo.push('Permission button clicked');
            button.textContent = 'Requesting...';
            button.disabled = true;
            
            try {
                await requestPermissions();
            } catch (error) {
                debugInfo.push('Error in handlePermissionClick: ' + error.message);
                console.error('Permission error:', error);
            }
            
            updateDebugDisplay();
        }
        
        async function requestPermissions() {
            const button = document.getElementById('permission-button');
            const status = document.getElementById('status');
            
            try {
                let orientationPermission = 'granted';
                let motionPermission = 'granted';
                
                // Request DeviceOrientationEvent permission
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    debugInfo.push('Requesting orientation permission...');
                    orientationPermission = await DeviceOrientationEvent.requestPermission();
                    debugInfo.push('Orientation permission: ' + orientationPermission);
                }
                
                // Request DeviceMotionEvent permission  
                if (typeof DeviceMotionEvent.requestPermission === 'function') {
                    debugInfo.push('Requesting motion permission...');
                    motionPermission = await DeviceMotionEvent.requestPermission();
                    debugInfo.push('Motion permission: ' + motionPermission);
                }
                
                if (orientationPermission === 'granted' || motionPermission === 'granted') {
                    setupOrientationListeners();
                    button.style.display = 'none';
                    permissionGranted = true;
                    status.innerHTML = '<small>Device motion enabled!</small>';
                    debugInfo.push('Permissions granted, listeners set up');
                } else {
                    button.style.display = 'none';
                    status.innerHTML = '<small>Permission denied - using mouse</small>';
                    debugInfo.push('Permission denied');
                }
            } catch (error) {
                debugInfo.push('Permission error: ' + error.message);
                console.error('Error requesting permission:', error);
                
                // Try to set up listeners anyway (for older browsers)
                setupOrientationListeners();
                button.style.display = 'none';
                status.innerHTML = '<small>Trying without permission...</small>';
            }
            
            updateDebugDisplay();
        }
        
        function setupOrientationListeners() {
            debugInfo.push('Setting up orientation listeners...');
            
            // Listen to device orientation events
            if (window.DeviceOrientationEvent) {
                window.addEventListener('deviceorientation', handleOrientation);
                debugInfo.push('DeviceOrientation listener added');
            }
            
            // Listen to device motion events (for acceleration data)
            if (window.DeviceMotionEvent) {
                window.addEventListener('devicemotion', handleMotion);
                debugInfo.push('DeviceMotion listener added');
            }
            
            // Test the listeners with a timeout
            setTimeout(() => {
                if (orientation.gamma === 0 && orientation.beta === 0) {
                    debugInfo.push('No orientation data received after 2s');
                    // Try alternative approach for some Android devices
                    tryAlternativeListeners();
                } else {
                    debugInfo.push('Orientation data received successfully');
                }
                updateDebugDisplay();
            }, 2000);
        }
        
        function tryAlternativeListeners() {
            debugInfo.push('Trying alternative listeners...');
            
            // Some devices need this approach
            window.ondeviceorientation = handleOrientation;
            window.ondevicemotion = handleMotion;
            
            updateDebugDisplay();
        }
        
        function handleOrientation(event) {
            // Store orientation data
            orientation.alpha = event.alpha || 0; // Z-axis rotation (compass)
            orientation.beta = event.beta || 0;   // X-axis rotation (tilt front/back)
            orientation.gamma = event.gamma || 0; // Y-axis rotation (tilt left/right)
            
            // Use gamma and beta for movement (more intuitive)
            targetOffsetX = map(orientation.gamma, -45, 45, -100, 100);
            targetOffsetY = map(orientation.beta, -45, 45, -100, 100);
            
            // Update info display
            updateOrientationDisplay();
            
            // Mark as working
            if (!permissionGranted && (orientation.gamma !== 0 || orientation.beta !== 0)) {
                permissionGranted = true;
                const status = document.getElementById('status');
                status.innerHTML = '<small>Device motion active!</small>';
                debugInfo.push('Device motion detected without permission API');
                updateDebugDisplay();
            }
        }
        
        function handleMotion(event) {
            // Store motion data (acceleration)
            if (event.acceleration) {
                motion.x = event.acceleration.x || 0;
                motion.y = event.acceleration.y || 0;
                motion.z = event.acceleration.z || 0;
            }
        }
        
        function updateOrientationDisplay() {
            const orientationData = document.getElementById('orientation-data');
            orientationData.innerHTML = 
                `γ: ${orientation.gamma.toFixed(1)}° ` +
                `β: ${orientation.beta.toFixed(1)}° ` +
                `α: ${orientation.alpha.toFixed(1)}°`;
        }
        
        function draw() {
            background(255); // White background
            
            if (!maskCanvas || !gridCanvas || width <= 0 || height <= 0) {
                return;
            }
            
            updateGridOffset();
            
            // Smooth interpolation to target offset
            gridOffsetX = lerp(gridOffsetX, targetOffsetX, 0.05);
            gridOffsetY = lerp(gridOffsetY, targetOffsetY, 0.05);
            
            // Clear and draw mask
            maskCanvas.clear();
            maskCanvas.fill(255);
            maskCanvas.noStroke();
            
            for (let circle of circles) {
                maskCanvas.ellipse(circle.x, circle.y, circle.radius * 2);
            }
            
            // Draw the grid
            drawGrid();
            
            // Apply masking
            try {
                gridCanvas.drawingContext.save();
                gridCanvas.drawingContext.globalCompositeOperation = 'destination-in';
                gridCanvas.drawingContext.drawImage(maskCanvas.canvas, 0, 0);
                gridCanvas.drawingContext.restore();
                
                image(gridCanvas, 0, 0);
            } catch (e) {
                console.warn('Error applying mask:', e);
            }
            
            // Add new circles randomly
            if (random() < 0.02) {
                addCircle(random(width), random(height));
            }
            
            // Update circles
            for (let i = circles.length - 1; i >= 0; i--) {
                circles[i].life -= 0.5;
                if (circles[i].life <= 0) {
                    circles.splice(i, 1);
                }
            }
        }
        
        function drawGrid() {
            var r_size = 6;
            var b_size = 9;
            var g_width = 6;
            var g_height = 3;
            var h_padding = 2;
            var v_padding = 2;
            var grid_spacing = b_size + h_padding;
            
            gridCanvas.clear();
            gridCanvas.background(0); // Black background
            gridCanvas.noStroke();
            gridCanvas.rectMode(CENTER);
            
            gridCanvas.push();
            
            // Apply offset for movement
            gridCanvas.translate(gridOffsetX, gridOffsetY);
            
            // Position and rotate
            gridCanvas.translate(gridCanvas.width/2, -gridCanvas.height/2);
            gridCanvas.rotate(PI/4);
            
            // Draw grid - expanded range for coverage
            for(var i = -100; i < 200; i++) {
                for(var j = -100; j < 200; j++) {
                    var x = j * grid_spacing;
                    var y = i * grid_spacing;
                    
                    if(i % 2 == 0) {
                        // red/green row
                        if(j % 2 == 0) {
                            gridCanvas.fill(255, 0, 0); // Red
                            gridCanvas.rect(x, y, r_size, r_size);
                        } else {
                            gridCanvas.fill(0, 255, 0); // Green
                            gridCanvas.rect(x, y, g_width, g_height);
                        }
                    } else {
                        // blue/green row
                        if(j % 2 == 0) {
                            gridCanvas.fill(0, 255, 0); // Green  
                            gridCanvas.rect(x, y, g_height, g_width);
                        } else {
                            gridCanvas.fill(0, 51, 255); // Blue #007bff
                            gridCanvas.rect(x, y, b_size, b_size);
                        }
                    }
                }
            }
            
            gridCanvas.pop();
        }
        
        function updateGridOffset() {
            // If device motion is not available or not granted, use mouse position
            if (!permissionGranted) {
                targetOffsetX = map(mouseX, 0, width, -50, 50);
                targetOffsetY = map(mouseY, 0, height, -50, 50);
            }
        }
        
        function addCircle(x, y) {
            // Constrain circles to screen bounds
            x = constrain(x, 0, width);
            y = constrain(y, 0, height);
            
            circles.push({
                x: x,
                y: y,
                radius: random(1.5, 4), // Small raindrop size
                life: 255,
                maxLife: 255
            });
            
            debugInfo.push(`Circle added at ${x.toFixed(1)}, ${y.toFixed(1)}`);
            updateDebugDisplay();
        }
        
        function windowResized() {
            // Update display info
            displayInfo.windowWidth = window.innerWidth;
            displayInfo.windowHeight = window.innerHeight;
            
            debugInfo.push(`Window resized: ${displayInfo.windowWidth}x${displayInfo.windowHeight}`);
            
            // Resize canvas
            resizeCanvas(displayInfo.windowWidth, displayInfo.windowHeight);
            
            // Handle retina displays
            pixelDensity(displayInfo.pixelDensity);
            
            displayInfo.canvasWidth = displayInfo.windowWidth;
            displayInfo.canvasHeight = displayInfo.windowHeight;
            
            debugInfo.push(`Canvas resized: ${displayInfo.canvasWidth}x${displayInfo.canvasHeight}`);
            
            if (width > 0 && height > 0) {
                if (maskCanvas) maskCanvas.remove();
                if (gridCanvas) gridCanvas.remove();
                
                maskCanvas = createGraphics(displayInfo.canvasWidth, displayInfo.canvasHeight);
                gridCanvas = createGraphics(displayInfo.canvasWidth, displayInfo.canvasHeight);
                
                // Set pixel density for offscreen canvases too
                maskCanvas.pixelDensity(displayInfo.pixelDensity);
                gridCanvas.pixelDensity(displayInfo.pixelDensity);
            }
            
            updateDebugDisplay();
        }
        
        function mousePressed() {
            // Use proper mouse coordinates
            addCircle(mouseX, mouseY);
        }
        
        function touchStarted() {
            // Handle touch events properly for retina displays
            if (touches.length > 0) {
                // Convert physical touch coordinates to logical coordinates
                // by dividing by pixel density
                let touchX = touches[0].x / displayInfo.pixelDensity;
                let touchY = touches[0].y / displayInfo.pixelDensity;
                addCircle(touchX, touchY);
            }
            return false; // Prevent default behavior
        }
    </script>
</body>
</html>